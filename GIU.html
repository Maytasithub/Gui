<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Assignment</title>
<style>
  body { margin: 0; overflow: hidden; }
  #controls {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(255, 255, 255, 0.9);
    padding: 10px;
    border-radius: 8px;
    font-family: system-ui, sans-serif;
    z-index: 1;
    width: 260px;
  }
  #controls button { margin: 2px 4px; user-select: none; }
  #controls span { font-weight: bold; min-width: 40px; display: inline-block; text-align: right; }
</style>
</head>
<body>
<div id="controls">
  <div>
    <strong>แสงทิศทาง</strong><br />
    <button class="repeat-btn" data-fn="changeLight" data-args="directional,0.1">+ </button>
    <button class="repeat-btn" data-fn="changeLight" data-args="directional,-0.1">- </button>
    <span id="dirValue">1.00</span>
  </div>

  <div>
    <strong>แสงโดยรอบ</strong><br />
    <button class="repeat-btn" data-fn="changeLight" data-args="ambient,0.1">+ </button>
    <button class="repeat-btn" data-fn="changeLight" data-args="ambient,-0.1">- </button>
    <span id="ambValue">0.40</span>
  </div>

  <div>
    <strong>ปรับค่าเงา</strong><br />
    <button class="repeat-btn" data-fn="changeShadowBias" data-args="0.0001">+</button>
    <button class="repeat-btn" data-fn="changeShadowBias" data-args="-0.0001">-</button>
    <span id="shadowValue">0.000500</span>
  </div>

  <div>
    <strong>ขยับแสง (แกน X)</strong><br />
    <button class="repeat-btn" data-fn="moveLight" data-args="x,0.5">ขวา</button>
    <button class="repeat-btn" data-fn="moveLight" data-args="x,-0.5">ซ้าย</button>
    <span id="lightX">5.00</span>
  </div>

  <div>
    <strong>ขยับแสง (แกน Y)</strong><br />
    <button class="repeat-btn" data-fn="moveLight" data-args="y,0.5">ขึ้น</button>
    <button class="repeat-btn" data-fn="moveLight" data-args="y,-0.5">ลง</button>
    <span id="lightY">10.00</span>
  </div>

  <div>
    <strong>ปุ่มเดิน</strong><br />
    <div>W เดินหน้า <br> S ถอยหลัง <br> A ซ้าย <br> D ขวา</div>
  </div>

  <div>
    <strong>หมุนแสงรอบแกน Y</strong><br />
    <button id="btnRotateCW">ขวา</button>
    <button id="btnRotateCCW">ซ้าย</button>
    <span id="lightRotationAngle">0°</span>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
<script>
  let scene, camera, renderer, controls;
  let directionalLight, ambientLight;
  let model, blackModel;
  let shadowBias = 0.0005;
  let rotateDirection = 0;
  const rotateSpeed = 0.05;
  let repeatInterval = null;

  init();
  document.getElementById('shadowValue').innerText = shadowBias.toFixed(6);
  animate();

  function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 5);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    
    directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    directionalLight.position.set(5, 10, 5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    directionalLight.shadow.camera.left = -10;
    directionalLight.shadow.camera.right = 10;
    directionalLight.shadow.camera.top = 10;
    directionalLight.shadow.camera.bottom = -10;
    directionalLight.shadow.bias = shadowBias;
    directionalLight.shadow.radius = 2;
    scene.add(directionalLight);

    ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

   
    const textureLoader = new THREE.TextureLoader();
    const floorTexture = textureLoader.load('468909928_1744389426396838_530694724198012768_n.jpg');
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
   
    const planeMaterial = new THREE.MeshStandardMaterial({
      map: floorTexture,
      roughness: 1,
      metalness: 0
    });
    const plane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), planeMaterial);
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    scene.add(plane);

   
    const exrLoader = new THREE.EXRLoader();
    exrLoader.load(
      'unfinished_office_night_4k.exr',
      function (texture) {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        scene.background = texture;
        scene.environment = texture;   
      },
      undefined,
      function (err) { console.error('EXR load error:', err); }
    );

    
    const loader = new THREE.GLTFLoader();

    
    loader.load(
      'five2.glb',
      function (gltf) {
        model = gltf.scene;
        model.scale.set(1, 1, 1);
        model.position.set(-5, 0, 0);
        model.traverse(node => {
          if (node.isMesh && node.material) {
            node.castShadow = true;
            node.receiveShadow = true;
            node.material.metalness = 1.0;
            node.material.roughness = 0.1;
            node.material.envMapIntensity = 1.0;
          }
        });
        scene.add(model);
      },
      undefined,
      function (err) { console.error('five2.glb load error:', err); }
    );

    
    loader.load(
      'black.glb',
      function (gltf) {
        blackModel = gltf.scene;
        blackModel.position.set(-5, 1, -4);
        blackModel.scale.set(5, 5, 5);
        blackModel.traverse(node => {
          if (node.isMesh && node.material) {
            node.castShadow = true;
            node.receiveShadow = true;
            node.material.metalness = 1.0;
            node.material.roughness = 0.1;
            node.material.envMapIntensity = 1.0;
          }
        });
        scene.add(blackModel);
      },
      undefined,
      function (err) { console.error('black.glb load error:', err); }
    );

    
    loader.load(
      'wanted.glb',
      function (gltf) {
        const newModel = gltf.scene;
        newModel.scale.set(5, 5, 5);
        newModel.position.set(6, 0, 0);
        newModel.traverse(node => {
          if (node.isMesh && node.material) {
            node.castShadow = true;
            node.receiveShadow = true;
            node.material.metalness = 1.0;
            node.material.roughness = 0.1;
            node.material.envMapIntensity = 1.0;
          }
        });
        scene.add(newModel);
      },
      undefined,
      function (err) { console.error('wanted.glb load error:', err); }
    );

    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    
    window.addEventListener('keydown', (event) => {
      if (!model) return;
      switch (event.key) {
        case 'w': model.position.z -= 0.1; break;
        case 's': model.position.z += 0.1; break;
        case 'a': model.position.x -= 0.1; break;
        case 'd': model.position.x += 0.1; break;
        case 'ArrowLeft': model.rotation.y -= 0.1; break;
        case 'ArrowRight': model.rotation.y += 0.1; break;
        case 'ArrowUp': model.rotation.x -= 0.1; break;
        case 'ArrowDown': model.rotation.x += 0.1; break;
      }
    });


    document.getElementById('lightX').innerText = directionalLight.position.x.toFixed(2);
    document.getElementById('lightY').innerText = directionalLight.position.y.toFixed(2);

    
    const btnRotateCW = document.getElementById('btnRotateCW');
    const btnRotateCCW = document.getElementById('btnRotateCCW');
    btnRotateCW.addEventListener('mousedown', () => { rotateDirection = 1; });
    btnRotateCW.addEventListener('mouseup',   () => { rotateDirection = 0; });
    btnRotateCW.addEventListener('mouseleave',() => { rotateDirection = 0; });
    btnRotateCCW.addEventListener('mousedown', () => { rotateDirection = -1; });
    btnRotateCCW.addEventListener('mouseup',   () => { rotateDirection = 0; });
    btnRotateCCW.addEventListener('mouseleave',() => { rotateDirection = 0; });

    
    const repeatButtons = document.querySelectorAll('.repeat-btn');
    repeatButtons.forEach(btn => {
      btn.addEventListener('mousedown', () => {
        callButtonFunction(btn);
        repeatInterval = setInterval(() => callButtonFunction(btn), 100);
      });
      ['mouseup','mouseleave','mouseout'].forEach(ev => btn.addEventListener(ev, () => clearInterval(repeatInterval)));
    });
  }

  function callButtonFunction(button) {
    const fnName = button.getAttribute('data-fn');
    const argsString = button.getAttribute('data-args');
    let args = [];
    if (argsString) {
      args = argsString.split(',').map(s => {
        s = s.trim();
        return isNaN(s) ? s : parseFloat(s);
      });
    }
    if (typeof window[fnName] === 'function') window[fnName](...args);
  }

  function changeLight(type, delta) {
    if (type === 'directional') {
      directionalLight.intensity = Math.min(5, Math.max(0, directionalLight.intensity + delta));
      document.getElementById('dirValue').innerText = directionalLight.intensity.toFixed(2);
    }
    if (type === 'ambient') {
      ambientLight.intensity = Math.min(5, Math.max(0, ambientLight.intensity + delta));
      document.getElementById('ambValue').innerText = ambientLight.intensity.toFixed(2);
    }
  }

  function changeShadowBias(delta) {
    shadowBias = Math.min(0.01, Math.max(-0.01, shadowBias + delta));
    directionalLight.shadow.bias = shadowBias;
    document.getElementById('shadowValue').innerText = shadowBias.toFixed(6);
  }

  function moveLight(axis, delta) {
    directionalLight.position[axis] += delta;
    document.getElementById('lightX').innerText = directionalLight.position.x.toFixed(2);
    document.getElementById('lightY').innerText = directionalLight.position.y.toFixed(2);
  }

  function rotateLight(angle) {
    const radius = Math.hypot(directionalLight.position.x, directionalLight.position.z);
    const currentAngle = Math.atan2(directionalLight.position.z, directionalLight.position.x);
    const newAngle = currentAngle + angle;
    directionalLight.position.x = radius * Math.cos(newAngle);
    directionalLight.position.z = radius * Math.sin(newAngle);
    
    document.getElementById('lightX').innerText = directionalLight.position.x.toFixed(2);
    document.getElementById('lightY').innerText = directionalLight.position.y.toFixed(2);
    let degrees = (newAngle * 180 / Math.PI) % 360; if (degrees < 0) degrees += 360;
    document.getElementById('lightRotationAngle').innerText = degrees.toFixed(1) + '°';
  }

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    if (rotateDirection !== 0) rotateLight(rotateDirection * rotateSpeed);
    renderer.render(scene, camera);
  }
</script>
</body>
</html>
